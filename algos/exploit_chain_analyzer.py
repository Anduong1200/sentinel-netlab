#!/usr/bin/env python3
"""
Sentinel NetLab - Exploit Chain Analyzer
Correlates multiple independent alerts into high-level attack chains.
"""

import logging
import time
from dataclasses import dataclass, field
from datetime import UTC, datetime
from typing import Any

logger = logging.getLogger(__name__)

@dataclass
class ChainConfig:
    """Configuration for exploit chain analysis"""
    window_seconds: int = 300  # 5 minutes correlation window
    min_alerts_for_chain: int = 2

@dataclass
class AttackChain:
    """Represents a sequence of related alerts"""
    chain_id: str
    target_bssid: str | None
    attacker_mac: str | None
    alerts: list[dict] = field(default_factory=list)
    first_seen: float = field(default_factory=time.time)
    last_seen: float = field(default_factory=time.time)
    
    @property
    def severity(self) -> str:
        if any(a.get("severity") == "CRITICAL" for a in self.alerts):
            return "CRITICAL"
        return "HIGH"

class ExploitChainAnalyzer:
    """
    Correlates multiple alerts into attack chains.
    
    Example Chains:
    - Deauth Flood -> Evil Twin -> Credential Harvesting
    - Jamming -> Rogue AP -> Karma
    - Probing -> Password Spraying -> Association
    """
    
    def __init__(self, config: ChainConfig | None = None):
        self.config = config or ChainConfig()
        self.active_chains: list[AttackChain] = []
        self.chain_count = 0
        
    def analyze(self, alert: dict[str, Any]) -> dict[str, Any] | None:
        """
        Ingest a new alert and check if it belongs to an existing or new chain.
        """
        bssid = alert.get("bssid") or alert.get("target_bssid")
        attacker = alert.get("source_mac") or alert.get("suspect_bssid")
        
        now = time.time()
        self._cleanup(now)
        
        # Try to find matching chain
        matched_chain = None
        for chain in self.active_chains:
            # Match by BSSID or Attacker MAC
            if (bssid and bssid == chain.target_bssid) or \
               (attacker and attacker == chain.attacker_mac):
                matched_chain = chain
                break
                
        if matched_chain:
            matched_chain.alerts.append(alert)
            matched_chain.last_seen = now
            return self._create_chain_alert(matched_chain)
        else:
            # Start new potential chain
            new_id = f"CHN-{datetime.now().strftime('%Y%m%d%H%M%S')}-{self.chain_count:02d}"
            self.chain_count += 1
            new_chain = AttackChain(
                chain_id=new_id,
                target_bssid=bssid,
                attacker_mac=attacker,
                alerts=[alert]
            )
            self.active_chains.append(new_chain)
            
        return None

    def _create_chain_alert(self, chain: AttackChain) -> dict[str, Any]:
        """Convert a chain into a high-level incident alert"""
        types = [a.get("alert_type") for a in chain.alerts]
        
        return {
            "alert_type": "exploit_chain",
            "severity": chain.severity,
            "title": f"Complex Exploit Chain: {' -> '.join(types)}",
            "description": (
                f"Multi-stage attack detected involving {len(chain.alerts)} distinct techniques. "
                f"Indicators suggest a targeted attempt against {chain.target_bssid or 'multiple targets'}."
            ),
            "chain_id": chain.chain_id,
            "timestamp": datetime.now(UTC).isoformat(),
            "evidence": {
                "alert_sequence": chain.alerts,
                "attacker_mac": chain.attacker_mac,
                "target_bssid": chain.target_bssid,
                "duration_seconds": round(chain.last_seen - chain.first_seen, 1)
            },
            "mitre_attack": "TA0001" # Initial Access (Tactic)
        }

    def _cleanup(self, now: float):
        """Remove old chains"""
        cutoff = now - self.config.window_seconds
        self.active_chains = [c for c in self.active_chains if c.last_seen > cutoff]

if __name__ == "__main__":
    # Smoke test
    analyzer = ExploitChainAnalyzer()
    
    # 1. Deauth
    analyzer.analyze({"alert_type": "deauth_flood", "bssid": "AA:BB:CC:11:22:33", "severity": "MEDIUM"})
    # 2. Evil Twin (same BSSID)
    result = analyzer.analyze({"alert_type": "evil_twin", "target_bssid": "AA:BB:CC:11:22:33", "severity": "HIGH"})
    
    if result:
        print(f"Detected Chain: {result['title']}")
