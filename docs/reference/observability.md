# Observability Contract

This document defines the **contracts** for Metrics, Logs, and Tracing within Sentinel NetLab.
All services must adhere to this spec to ensure consistent dashboards, alerts, and debugging workflows.

## 1. Correlation Identifiers
To trace a request end-to-end (Client -> Proxy -> Controller -> Queue -> Worker -> DB), we use the following IDs:

| ID | propagation Header | Description | Required? |
| :--- | :--- | :--- | :--- |
| `request_id` | `X-Request-ID` | Unique ID per HTTP request. Generated by Nginx or Controller if missing. | **Yes** |
| `sensor_id` | `X-Sensor-ID` | Identity of the sensor. | Contextual |
| `batch_id` | `X-Batch-ID` | Unique ID of a telemetry batch. Used for idempotency. | Contextual |

### Log Context
All structured logs must include these context fields if available:
```json
{
  "request_id": "req-123...",
  "sensor_id": "sensor-01",
  "batch_id": "batch-abc..."
}
```

## 2. Structured Logging
All applications in Production **MUST** log in JSON format. Human-readable text logs are for Dev only.

### Schema
```json
{
  "time": "ISO8601",
  "level": "INFO|WARN|ERROR",
  "service": "controller|worker|sensor",
  "name": "logger.name",
  "message": "Human readable message",
  "data": { ...structured_payload... },
  "context": { ...correlation_ids... }
}
```

### Redaction Rules (PII/Secrets)
*   **NEVER** log `Authorization` headers.
*   **NEVER** log raw `password`, `token`, `secret`, `signature`.
*   **NEVER** log full request bodies unless strictly necessary for debug (and redacted).
*   **TRUNCATE** large fields (>1KB) to prevent DoS.

## 3. Metrics (Prometheus)

### Naming Convention
*   **Prefix**: `sentinel_<service>_` (e.g., `sentinel_controller_`)
*   **Units**: `_seconds`, `_bytes`, `_total`

### Cardinality Policy
*   **RESTRICTED LABELS**: High cardinality labels are **FORBIDDEN** in Prometheus.
    *   ❌ `user_id`, `email`, `bssid`, `ssid`, `client_ip` (raw), `request_id`
    *   ✅ `status`, `method`, `path` (templated), `reason`, `sensor_id` (only if sensor count < 10k)
    
### Core Metrics (P0)

#### Controller Ingest
| Metric | Type | Labels | Description |
| :--- | :--- | :--- | :--- |
| `ingest_requests_total` | Counter | `status` (2xx, 4xx, 5xx) | Throughput & Availability |
| `ingest_success_total` | Counter | - | Successful ingestions |
| `ingest_fail_total` | Counter | `reason` (auth, validation, throttle, etc.) | Failure drill-down |
| `ingest_latency_seconds` | Histogram | - | End-to-end latency |
| `backpressure_total` | Counter | - | Throttling events |

#### Queue & Worker
| Metric | Type | Labels | Description |
| :--- | :--- | :--- | :--- |
| `queue_backlog_size` | Gauge | `queue_name` | Current depth |
| `queue_oldest_age_seconds` | Gauge | `queue_name` | Lag (Head-of-line) |
| `worker_processed_total` | Counter | `result` (success, retry, dead) | Work throughput |

#### Sensor Health
| Metric | Type | Labels | Description |
| :--- | :--- | :--- | :--- |
| `sensor_heartbeat_age_seconds` | Gauge | `sensor_id` | Liveness check |
| `alert_emitted_total` | Counter | `severity`, `detector` | Detection volume |

## 4. Dashboards (Standard Views)

### Use Case 1: "Is Ingest Broken?"
*   Panel: `ingest_success_rate` (Success / Total) over 5m window.
*   Panel: `ingest_fail_total` by `reason`.

### Use Case 2: "Is Processing Lagging?"
*   Panel: `queue_oldest_age_seconds`. If > 60s, we are lagging.
*   Panel: `worker_processed_total` rate.

### Use Case 3: "Is a Sensor Offline?"
*   Table: `sensor_heartbeat_age_seconds` > 300s (RED).
